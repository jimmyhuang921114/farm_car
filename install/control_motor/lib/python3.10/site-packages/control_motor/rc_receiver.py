from serial import Serial, SerialException
import json
from pathlib import Path

import rclpy
from rclpy.node import Node
from std_msgs.msg import String
from rc_receiver_if.msg import ReceiverData
import diff_wheel as wheel_trans

class RC_Receiver(Node):
    def __init__(self):
        super().__init__('rc_receiver')
        wheel_trans.load_config()
        self.publisher_ = self.create_publisher(ReceiverData, '/rc_receiver', 10)
        self.sub = self.create_subscription(ReceiverData, '/rc_receiver', self.loopbackCallback, 10)
        
        self.channel_data = [1000] * 18
        self.wheel_control = [0, 0]
        
        self.timeout_timer = self.create_timer(3, self.timeoutTimerCallback)
        
        # 嘗試載入配置檔案
        config_path = Path("rc_receiver_config.json")
        if not config_path.is_file():
            self.get_logger().error(f'Configuration file not found at {config_path}. Exiting...')
            exit(1)

        with open(config_path, 'r') as file:    
            config = json.load(file)

        port = config.get("port", "/dev/ttyUSB0")
        self.get_logger().info(f'Using serial port: "{port}"')
        
        try:
            self.serial = Serial(port, 115200)
        except SerialException as e:
            self.get_logger().error(f'Failed to open serial port {port}, error:\n\t{e}')
            exit(1)
            
        self.get_logger().info('Init finish')
        self.input_buf = b''
        self.serial_handle_timer = self.create_timer(0.01, self.serialHandleTimerCallback)
        self.publish_timer = self.create_timer(0.01, self.publishTimerCallback)

    def parseData(self, data: list) -> bool:
        # Calculate checksum
        checksum = sum(data[:30]) ^ 0xFFFF
        received_checksum = data[30] + (data[31] << 8)
        if checksum != received_checksum:
            self.get_logger().warning(f"Checksum failed {checksum}/{received_checksum}")
            return False
        
        output_data = [1000] * 18
        output_data[0] = data[2] + ((data[3] & 0x0F) << 8)
        output_data[1] = data[4] + ((data[5] & 0x0F) << 8)
        output_data[2] = data[6] + ((data[7] & 0x0F) << 8)
        output_data[3] = data[8] + ((data[9] & 0x0F) << 8)
        output_data[4] = data[10] + ((data[11] & 0x0F) << 8)
        output_data[5] = data[12] + ((data[13] & 0x0F) << 8)
        output_data[6] = data[14] + ((data[15] & 0x0F) << 8)
        output_data[7] = data[16] + ((data[17] & 0x0F) << 8)
        output_data[8] = data[18] + ((data[19] & 0x0F) << 8)
        output_data[9] = data[20] + ((data[21] & 0x0F) << 8)
        output_data[10] = data[22] + ((data[23] & 0x0F) << 8)
        output_data[11] = data[24] + ((data[25] & 0x0F) << 8)
        output_data[12] = data[26] + ((data[27] & 0x0F) << 8)
        output_data[13] = data[28] + ((data[29] & 0x0F) << 8)
        output_data[14] = ((data[3] & 0xF0) >> 4) + (data[5] & 0xF0) + ((data[7] & 0xF0) << 4)
        output_data[15] = ((data[9] & 0xF0) >> 4) + (data[11] & 0xF0) + ((data[13] & 0xF0) << 4)
        output_data[16] = ((data[15] & 0xF0) >> 4) + (data[17] & 0xF0) + ((data[19] & 0xF0) << 4)
        output_data[17] = ((data[21] & 0xF0) >> 4) + (data[23] & 0xF0) + ((data[25] & 0xF0) << 4)
        
        
        self.get_logger().debug(f"output data: {output_data}")
        self.channel_data = output_data
        linear_vel = (output_data[1] - 1500) * 0.001
        ang_vel = -(output_data[0] - 1500) * 0.001
        L, R = wheel_trans.calculate_motor_speeds(linear_vel, ang_vel)
        self.wheel_control = [L, R]
        return True
    
    def serialHandleTimerCallback(self):
        try:
            if self.serial.in_waiting > 0:
                self.input_buf += self.serial.read_all()
            if len(self.input_buf) >= 2:
                start = self.input_buf.find(b'\x20\x40')
                if start == -1:
                    return
                if start != 0:
                    self.get_logger().warning(f"Unsync detected, adjusting...")
                    self.input_buf = self.input_buf[start:]
                if len(self.input_buf) >= 32:
                    local_buf = self.input_buf[:32]
                    self.input_buf = self.input_buf[32:]
                    data = list(local_buf)
                    success = self.parseData(data)
                    if success:
                        self.timeout_timer.reset()
                        self.input_buf = b''
        except SerialException as e:
            self.get_logger().error(f'Serial error detected: {e}')
            self.timeoutTimerCallback()

    def timeoutTimerCallback(self):
        self.get_logger().warning(f"Timeout detected")
        receiver_data = ReceiverData()
        receiver_data.channel_data = [1000] * 18
        self.publisher_.publish(receiver_data)
        
    def loopbackCallback(self, data: ReceiverData):
        self.get_logger().info(f'loopback: {data.channel_data}')
        self.get_logger().info(f'loopback: {data.wheel_control}')
        
    def publishTimerCallback(self):
        receiver_data = ReceiverData()
        receiver_data.channel_data = self.channel_data
        receiver_data.wheel_control = self.wheel_control
        self.publisher_.publish(receiver_data)

def main(args=None):
    rclpy.init(args=args)
    rc_receiver = RC_Receiver()
    rclpy.spin(rc_receiver)
    rc_receiver.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
